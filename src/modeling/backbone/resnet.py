from torch import nn
from torchvision import models
from torchvision.models import (
    ResNet18_Weights, 
    ResNet34_Weights, 
    ResNet50_Weights, 
    ResNeXt50_32X4D_Weights
)

from src.utils.registry import REGISTRY

@REGISTRY.register('resnet18')
class ResNet18Model(nn.Module):
    def __init__(self, num_classes=5, classify=True):
        super(ResNet18Model, self).__init__()
        self.resnet = models.resnet18(weights=ResNet18_Weights.DEFAULT)
        
        if classify:
            self.resnet.fc = nn.Linear(512, num_classes)
        else:
            features = nn.ModuleList(self.resnet.children())[:-1]
            self.resnet = nn.Sequential(*features).append(nn.Flatten())
    
    def forward(self, inputs):
        return self.resnet(inputs)
    
    def get_layer_groups(self):
        linear_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' in param_tuple[0], self.resnet.named_parameters())]
        other_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' not in param_tuple[0], self.resnet.named_parameters())]
        param_groups = {
            'classifier': linear_layers,
            'feature_extractor': other_layers 
        }
        return param_groups
    
@REGISTRY.register('resnet34')
class ResNet34Model(nn.Module):
    def __init__(self, num_classes=5, classify=True):
        super(ResNet34Model, self).__init__()
        self.resnet = models.resnet34(weights=ResNet34_Weights.DEFAULT)
        
        if classify:
            self.resnet.fc = nn.Linear(512, num_classes)
        else:
            features = nn.ModuleList(self.resnet.children())[:-1]
            self.resnet = nn.Sequential(*features).append(nn.Flatten())
    
    def forward(self, inputs):
        return self.resnet(inputs)
    
    def get_layer_groups(self):
        linear_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' in param_tuple[0], self.resnet.named_parameters())]
        other_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' not in param_tuple[0], self.resnet.named_parameters())]
        param_groups = {
            'classifier': linear_layers,
            'feature_extractor': other_layers 
        }
        return param_groups
    
@REGISTRY.register('resnet50')
class ResNet50Model(nn.Module):
    def __init__(self, num_classes=5, classify=True):
        super(ResNet50Model, self).__init__()
        self.resnet = models.resnet50(weights=ResNet50_Weights.DEFAULT)
        
        if classify:
            self.resnet.fc = nn.Linear(2048, num_classes)
        else:
            features = nn.ModuleList(self.resnet.children())[:-1]
            self.resnet = nn.Sequential(*features).append(nn.Flatten())
    
    def forward(self, inputs):
        return self.resnet(inputs)
    
    def get_layer_groups(self):
        linear_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' in param_tuple[0], self.resnet.named_parameters())]
        other_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' not in param_tuple[0], self.resnet.named_parameters())]
        param_groups = {
            'classifier': linear_layers,
            'feature_extractor': other_layers 
        }
        return param_groups
    
@REGISTRY.register('resnext50')
class ResNeXt50Model(nn.Module):
    def __init__(self, num_classes=5, classify=True):
        super(ResNeXt50Model, self).__init__()
        self.resnet = models.resnext50_32x4d(weights=ResNeXt50_32X4D_Weights.DEFAULT)
        
        if classify:
            self.resnet.fc = nn.Linear(2048, num_classes)
        else:
            features = nn.ModuleList(self.resnet.children())[:-1]
            self.resnet = nn.Sequential(*features).append(nn.Flatten())
    
    def forward(self, inputs):
        return self.resnet(inputs)
    
    def get_layer_groups(self):
        linear_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' in param_tuple[0], self.resnet.named_parameters())]
        other_layers = [elem[1] for elem in filter(lambda param_tuple: 'fc' not in param_tuple[0], self.resnet.named_parameters())]
        param_groups = {
            'classifier': linear_layers,
            'feature_extractor': other_layers 
        }
        return param_groups